from itertools import permutations

class IC:
    def __init__(self, mem, p=0, inp=[], out=[]):
        self.d = mem
        self.p = p
        self.inp = inp
        self.out = out
        self.hcf = False
    def step(self):
        def R(d,i,p): return d[p] if i else d[d[p]]
        p = self.p
        d = self.d
        o = d[p] % 100
        i = [int(i) for i in str(d[p])[:-2]]
        i.reverse()
        i += [0] * (4 - len(i))
        if o == 1:
            d[d[p+3]] = R(d,i[0],p+1) + R(d,i[1],p+2)
            self.p += 4
        elif o == 2:
            d[d[p+3]] = R(d,i[0],p+1) * R(d,i[1],p+2)
            self.p += 4
        elif o == 3:
            d[d[p+1]] = self.inp.pop(0)
            self.p += 2
        elif o == 4:
            self.out.append(R(d,i[0],p+1))
            self.p += 2
        elif o == 5:
            if R(d,i[0],p+1) != 0:
                self.p = R(d,i[1],p+2)
            else:
                self.p += 3
        elif o == 6:
            if R(d,i[0],p+1) == 0:
                self.p = R(d,i[1],p+2)
            else:
                self.p += 3
        elif o == 7:
            if R(d,i[0],p+1) < R(d,i[1],p+2):
                d[d[p+3]] = 1
            else:
                d[d[p+3]] = 0
            self.p += 4
        elif o == 8:
            if R(d,i[0],p+1) == R(d,i[1],p+2):
                d[d[p+3]] = 1
            else:
                d[d[p+3]] = 0
            self.p += 4
        elif o == 99:
            self.hcf = True
        else:
            raise Exception('err')

D=[3,8,1001,8,10,8,105,1,0,0,21,38,63,76,93,118,199,280,361,442,99999,3,9,101,3,9,9,102,3,9,9,101,4,9,9,4,9,99,3,9,1002,9,2,9,101,5,9,9,1002,9,5,9,101,5,9,9,1002,9,4,9,4,9,99,3,9,101,2,9,9,102,3,9,9,4,9,99,3,9,101,2,9,9,102,5,9,9,1001,9,5,9,4,9,99,3,9,102,4,9,9,1001,9,3,9,1002,9,5,9,101,2,9,9,1002,9,2,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,2,9,9,4,9,99,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,99,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,99]
msig = 0
for pa in permutations([5,6,7,8,9]):
    sig = 0
    amps = [IC(D[:], inp=[p]) for p in pa]
    sigs = [0 for p in pa]
    run = True
    while run:
        for i in range(len(amps)):
            amp = amps[i]
            amp.inp.append(sig)
            while not amp.hcf and len(amp.out)==0:
                amp.step()
            if len(amp.out) > 0:
                sig = sigs[i] = amp.out.pop(0)
            if amp.hcf:
                run = False
                break
    msig = max(msig, sig)
print(msig)
